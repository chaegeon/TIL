# 파이썬 인터프리터의 이해

# 개발환경

- IDE (Intergrated Development Environment)

  - 통합개발환경

  - 개발에 필요한 여러가지를 하나의 프로그램으로 다 사용할 수 있는 것

  - 개발에 반드시 필요한 두 가지

    - 인터프리터

    - 에디터(텍스트 에디터), 메모장 같은거라고 보면 된다
      - 한글이나 워드는 개발용으로는 사용할 수 없음

    - 그 외에 개발에 필요한 여러가지 유틸들

- Jupyter (주피터)

  - 구글의 colab, 아마존의 AWS같은 환경이 `주피터` 라는 개발 환경 

  - 주로, 인공지능 하시는 분들이 즐겨 사용하는 환경

  - 일반적인 파이썬 개발환경과의 차이점

    - 파일의 확장자가 `.py`가 아닌, `.ipynb`라는 확장자를 사용
      - 이 두 파일은 호환되지 않음

    - 동작 방식도 다르다

      - 일반적인 파이썬 개발환경은 파일에 있는 파이썬 명령어들을 일괄적으로 전부 실행 

      - 주피터는 셀(블록) 단위로 실행

      - 하나의 파일에서 명령어들을 각각의 독립된 형태로 구성해서 따로따로 실행할 수 있다

      - 명령어만 독립적으로 구성할 수도 있다



## 파이썬 인터프리터

- 결국 기초 수업의 가장 큰 목표는 `인터프리터`가 어떻게 동작하는지? 를 익히는 과정
  - 파이썬을 이해한다?
    - 파이썬 인터프리터의 실행 과정을 이해하는 것과 동일
  - 인터프리터가 내가 입력한 명령어에 대해서 어떻게 해석하고, **어떤 결과를 돌려주는가?**를 이해하는 것이 가장 중요
  - 명령어를 실행하고, 어떻게 값이 돌아오는지를 눈으로 확인
- 언어의 실행에 따른 종류
  1. 컴파일 언어
     - C, C++, Java, ...
     - 컴퓨터는 숫자만 입력받을 수 있다
       - 다른 말로 바이너리(이진수)라고 한다
       - 0과 1로 이루어진 값만 처리가 가능(기계어)
       - 문자로 작성된 소스코드(파일)을 실행하기 위해서는 반드시 기계어로 바꿔줘야 한다
       - 문자로 작성된 소스코드(파일)을 기계어로 바꾸는 작업을 일괄적으로 하면 컴파일(번역) 한다고 한다
  2. 인터프리터 언어
     - 파이썬, 자바스크립트, R, 루비, PHP, ...
     - Line By LIne
       - 소스코드(파일)을 읽어 들여서 명령어 마다 그때그때 기계어로 번역 해서 실행
       - 그래서 컴파일 하는 과정이 없이 바로 실행이 가능 하다
       - 이 과정을 인터프리터가 처리를 해줌
- REPL (Read, Evaluation, Print, Loop)
  - 결국 인터프리터는 REPL 과정을 따라서 동작을 하게 된다
  - 컴파일(번역)과정이 없는것이 아니라 눈에 보이지 않을 뿐
  - Read: 입력된 명령어를 읽고
    - 이 과정에서 파이썬 인터프리터가 번역을 한다 => 기계어로
    - 문자로 된 명령어를 => 숫자(기계어/binary)로 변환
  - Evaluation: 명령어를 실행
  - Print: 명령어를 실행한 결과를 **돌려줌**
  - Loop: 이 과정을 계속 반복할 수 있음
- 모든 파이썬 명령어들은 인터프리터에 의해서 실행되는 것을 가정
  - 파일에 전부 기록 => 일괄적으로 한 번에 실행
  - 셀(블록) 단위로 나눠서 실행
  - 파이썬 쉘에서 명령어를 입력받아서 실행
- 주피터는 일반적인 개발 환경과 인터프리터와 중간적인 환경을 제공
  - 주피터는 REPL로 동작하는 대표적인 개발도구

---



## 자료의 타입

- 자료란 무엇인가?
  - 프로그래밍(코딩)을 하는 `대상`을 자료하고 한다.
    - 파일(엑셀, 그림, 텍스트, ...), 문자, 숫자, ...
    - 자료의 형태는 기본적으로 둘 중에 하나 ( 문자 / 숫자 )
      - 더 정확히 말하자면 숫자 하나이긴 하지만!
      - 숫자를 RGB로 해석하면, 색정보, 문자 인코딩을 하면 문자, ...
      - 결국, 컴퓨터에서 보여지는 모든 것들은 전부 숫자로 표현이 가능하다.
- 파이썬의 타입은 여러가지가 있다
  - 기본 타입은 숫자 (정수, 실수)
  - 파이썬의 기본 타입은 자료를 구성하는 가장 기본적인 `최소단위`가 된다



### 숫자

- 정수(Integer . int), 실수(float), 불리언(boolean . bool)
  - 분수, 복소수도 표현이 가능하긴 함
  - 숫자 체계는 일반적인 숫자 체계와 거의 동일하다
  - 파이썬의 실수는 우리가 아는 그 실수와는 다름
    - 정확하게는 소수(Decimal number)에 대한 표현이다



#### 정수 (Integer. int)

- `int`로 표현
- 음수, 0, 양수를 표현
- 일반적인 다른 언어들도 정수 타입을 가지고 있다
  - 정수는 크기를 가지고 있다 (4byte)
  - 파이썬은 정수를 표현하는데 있어서 크기가 제한되어 있지 않다
  - 아무리 큰 수라도 파이썬은 표현이 가능하다
  - 다만, 표현만 가능하고 속도는 그만큼 느려진다

---

파이썬에서 타입의 확인은 type() 명령을 통해서 가능

```
type(10)
>>> int

type(-10)
>>> int

type(0)
>>> int

# 수학적으로 -0 은 정의되어 있지 않지만, 파이썬은 -0에 대해 오류를 내지않고 0으로 바꿔서 처리를 해준다
type(-0)
>>> int

# -0은 존재할 수 없기 때문에, 파이썬은 0으로 해석할 뿐
-0
>>> 0
```

---



#### 실수 (Float)

- 파이썬은 `float` 타입 하나만 제공
  - 부동소수점 방식(!부동의 뜻은 은 '아니 불'에 '움직일 동'이 아니다!)
    - 움직이는 소수점 방식이라는 뜻
    - float (floating). 부유하다. 떠다닌다 라는 뜻
    - 소수점의 위치가 고정되어 있지 않고, 바뀐다는 의미
    - 소수점이 앞에 위치하면, 수의 표현은 작아져도 정밀한 수의 표현이 가능
    - 소수점이 뒤에 위치하면, 큰 수를 표현할 수 있지만, 정밀도는 낮아지게 된다

---

대부분의 언어는 실수형태를 정확히 처리할 수 없다

- 항상 오차가 생기고

- 아주 정밀한 자료를 다룬다고 해도 가장 근사된 값으로 표현되며

- 컴퓨터의 태생이 그렇다

```
type(10.12)
>>> float

# 앞, 뒤에 0을 생략할 수 있다
type(10.)
>>> float

type(.12)
>>> float

# 둘 다 생략한다면 숫자가 아닌게 되어버림
# 파이썬 인터프리터는 이렇게 애매한 경우 해석이 불가능하다
type(.)
>>> SyntaxError: EOL while scanning string literal
```

> > >SyntaxError 는 문법적인 에러. 이 에러가 뜬가면 문법적으로 틀렸기 때문에 빠드린 것이 있는지, 스펠링이 틀렸는지 등을 확인해 볼 것

---





#### 불리언 (Boolean . bool)

- 참, 거짓을 표현하는 값 (True, False) * 대소문자 주의
  - 숫자와 동일
  - True는 1과 같은 숫자이고, False 는 0과 같은 숫자이다

```
type(True)
>>> bool

# 그래서 이런 것도 가능
True + True + True
>>> 3
```



#### 문자열

- `문자`와`문자열`은 본래 구분되는 개념이다
  - `문자`는 단일 문자를 의미하며, 이 단일 문자의 집할을 `문자열`이라고 표현한다
  - 파이썬은 문자와 문자열을 구분하지 않는다
  - 파이썬은 단일 문자라는 개념이 없으며, 그냥 다 문자열이다
- 파이썬에서의 문자열을 표현하는 방법은 3가지가 있다
  - ' ' (작은 따옴표 . single quotations )
  - " " ( 큰 따옴표 . double quotations)
  - ''' ''' / """ """ (멀티라인 문자열)
    - 멀티라인을 제외하고 작은 따옴표와 큰 따옴표의 차이는 없다
    - 마음에 드는 거 쓰면 됨
    - 다만, Opening Quotations 와 Closing Quotations는 반드시 한 쌍으로 이루어져야 하고, 동인한 문자를 사용해야한다
      -  'hello" 이런식은 안 됨

---

###### 파이썬은 기본적으로 실행결과에 타입도 함께 명시해준다

- print는 기본적으로 문자열 출력임을 가정한다

- display는 출력된 결과의 타입도 함께 표현한다

```
# 기본적인 문자열의 표현
print('hello python')
display("hello python")
>>> hello python
>>>'hello python'  # 문자열이기 때문에 ''를 씌워서 보여줌

# 이 2개의 자료는 명확히 구분 가능하다
display(2)
display('2')
>>> 2     숫자
>>> '2'   문자열

# print는 구분이 안됨. 무조건 문자열 형태의 출력을 가정
print(2)
print('2')
>>> 2
>>> 2
```



> > > 여는 따옴표와 닫는 따옴표가 다른 경우

```
# 반드시 한 쌍으로 이루어져야 한다
'이렇게 열어놓고 닫아주지 않으면?
>>> SyntaxError: EOL while scanning string literal

# 여는 따옴표와 닫는 따옴표가 다른 경우에도 인터프리터는 확인할 수 없다
'이렇게 열고 이렇게 닫으면?"
>>> SyntaxError: EOL while scanning string literal
```

> > > SyntaxError 는 문법적인 에러
> > >
> > > EOL 은 End Of Line의 약자로, 라인의 끝을 알 수 없다는 뜻이다
> > >
> > > - 파이썬은 한 줄에 하나의 명령어 또는 하나의 문자열이 원칙이다
> > >
> > >   - 한 줄에 여러개의 명령어를 나눠서 사용할 수 없고
> > >
> > >   - 한 명령어를 여러 줄에 나눠서 사용할 수 없다

```
'hello
python'
>>> SyntaxError: EOL while scanning string literal

print('hello') print('python')
>>> SyntaxError: invalid syntax
```

###### 한 명령어를 여러 줄에 나눠서 사용할 수 있는 몇가지 방법

- 다음 라인으로 넘어가는 경우 역슬래시(\\)를 붙여준다

  - 역슬래시 ( \\ ) 키보드에서 백스페이스 근처에 위치

  - 한글 키보드인 경우 '원화'로 표현되어 있음

- 파이썬은 멀티라인 문자열을 지원한다
  - 문자열인 경우에만 사용이 가능

```
# 멀티라인은 ' 또는 " 상관없이 연속으로 3개를 입력하면 된다
'''hello
python'''
>>>'hello python'

"""hello
python"""
>>> 'hello python'

'hello \
python'
>>> 'hello python'
```



###### 여러개의 명령어를 한 줄에 사용하고 싶은 경우

- 세미콜론(;)

```
print('hello') ; print('python')
>>> hello
>>> python
```

##### 문자열을 처리하는 방법

- 기본적으로 컴퓨터는 숫자만 처리할 수 있다
  - 숫자로 표현할 수 없거나, 숫자가 아닌 데이터는 처리 불가능
  - 컴퓨터는 문자, 그림, 영상 드 ㅇ전부 인식할 수 없다
  - 정확하게는 이진수 / binary (0,1) 로만 처리가 가능
  - 심지어 뺄셈도 불가능하다
    - 덧셈만 가능 (2의 보수를 통한 뺄셈을 구현하는 방식)
- 그래서, 문자를 다루거나 저장을 하려면, 숫자가 아니면 안되는데
  - 각 문자에 해당하는 유일한 숫자를 정의한다
  - 영문 대/소문자, 숫자, 특수문자 대응하는 유일한 숫자 테이블
    - `아스키 코드`라고 부른다
      - 표준이다. 어떤 시스템이든 동일한 숫자를 이용한다

---

![](https://3.bp.blogspot.com/-aw0f_TovMoU/WNxD0O5hTjI/AAAAAAAAQGU/33SBPQ-jLo4pMk0jv42YsjinfBlG4JbdgCLcB/s640/%25EC%2595%2584%25EC%258A%25A4%25ED%2582%25A4%25EC%25BD%2594%25EB%2593%259C%25ED%2591%259C_01.jpg)



![](https://1.bp.blogspot.com/-NINVWqe17ug/WNxD0PQ-vnI/AAAAAAAAQGQ/13iKgvNkaocCGwqlV9BLbZf06oOVYIsWwCLcB/s640/%25EC%2595%2584%25EC%258A%25A4%25ED%2582%25A4%25EC%25BD%2594%25EB%2593%259C%25ED%2591%259C_02.jpg)

- 아스키 코드는 0부터 127까지 전부 128개의 문자에 대해서 대응되는 숫자 테이블을 의미한다
  - 모든 시스템이 동일한 값을 사용한다
- 왜 1바이트는 8비트가 되었을까?
  - bit : 컴퓨터가 정보를 처리하는 최소단위
    - 한개의 비트는 0 또는 1을 표현
    - 8비트는 2^8개 만큼의 수를 표현(256개의 숫자를 표현)
  - MSB (Most Signature Bit . 최상위부호비트)
    - MSB를 제외한 7개의 비트로 표현을 하면 2^7개 만큼 표현이 가능하고
    - 2^7 => 128개의 숫자를 표현할 수 있음
    - 즉, 자신들이 사용하는 문자체계에서 모든 숫자를 다 만드는데 7개의 비트면 충분했고, 부호까지 포함해도 8개의 비트면 모두 다 표현이 가능
    - 그래서 8비트는 1바이트가 되었다
- 영어권 국가들은 전혀 문제가 되지 않는다
  - 하지만 아시아 국가들은 문제가 많다..(한국, 일본, 중국, ...)
  - 1바이트로는 절대 문자를 전부 표현할 수가 없기 때문
  - 그래서 아주 오래된 언어들을 제외하면 거의 대부분의 언어들은 문자를 표현하는 최소 크기로 2바이트를 사용한다
  - 파이썬도 문자 하나를 표현하는데 2바이트를 사용
  - 심지어 파이썬은 한글 변수도 사용할 수 있다
- 한글은 숫자로 어떻게 표현할까?
  - 아스키 테이블을 사용할 수 없다
  - 한글을 표현할 수 있는 새로운 문자 인코딩셋을 만듦
  - 문자 => 숫자(인코딩) , 숫자 =>문자 (디코딩)
  - 한글을 표현할 수 있는 인코딩셋
    - UTF-8 , CP949, EUC-KR
    - 파이썬은 기본 UTF-8을 기본 인코딩셋으로 사용한다
    - 한글 윈도우즈같은 경우 기본 EUC-KR을 사용하는 경우가 많다



##### 눈에 보이는 것이 전부는 아니다 . CR / LF , 공백

- 키보드로부터 입력할 수 있는 모든 키는 전부 문자료 표현이 가능
  - 즉, 엔터도 문자!
- 기본적으로 엔터는 두 개의 문자로 표현을 한다
  - (옛날 타자기 용어)
  - CR (Carriagr Return . 해당 라인의 가장 앞으로 이동)
  - LF (Line Feed . 종이를 말아 올리는 작업)
    - 타자기에서 사용하던 용어를 그대로 엔터의 값으로 사용
    - 그런데 요즘은 LF 하나로만 표현하는 것이 추세
    - 에디터의 설정이나 운영체제에 따라 달라짐
    - 윈도우즈는 CR / LF의 두 문자를 모두 사용하는 것이 일반적
    - 맥 / 리눅스는 LF 한 문자로 표현
- 빈 문자와 공백은 다른 문자이다
  - 공백도 문자!
    - 공백은 쓴다라고 표현하지 않고, 띄어쓰기라고 표현
    - 공백은 그냥 문자와 문자 사이의 공백 정도로 생각, 문자라고 인식하지는 않는데, `공백도 문자이다`
    - 원고지를 생각해보자. 공백도 한 문자로 취급한다
- 코린이의 코드 작성시 주의사항!
  - 파이썬 인터프리터는 코드의 띄어쓰기, 대/소문자를 엄격하게 구분한다
  - 코드를 작성할 때, 공백과 대/소문자에 주의해서 작성을 하자

```
# 빈문자의 표현은 다음과 같다
''
>>> ''

#공백도 문자이다
' '
>>> ' '

# 빈문자와 공백은 엄연히 다른 문자이다
'' == ' '
>>> False
```

아스키 코드값이 다르면, 다른 문자이다

- 다른 문자처럼 보이지만, 같은 아스키 코드값을 가지면 같은 문자이다

  - 키보드의 역슬래시와 원화 문자는 다르게 보이지만, 같은 아스키 코드값을 가진다

  - 원화라 쓰고, 역슬래시라고 읽음

- 같은 한글이라고 하더라도, 인코딩 셋이 다르면 다른 문자이다

- 예외없이 모든 문자를 전부 정확하게 구분할 수 있다

```
# 대/소문자를 엄격하게 구분한다
print( 'a' == 'A')
>>> False
print('apple' == 'Apple')
>>> False
```



숫자와 문자는 다르다

```
# 숫자는 문자가 아니기 때문에 대/소문자를 구분하지 않는다
print( 10 == 0x0a )
>>> True
print(0x0a == 0x0A)
>>> Ture
```



숫자뿐만 아니라 문자도 대소 비교가 가능하다

- 문자인데 큰게 있어?
  - 있다
- 아스키 코드 값으로 비교

```
'a' > 'A'
>>> True
# a = 97 = 0x61
# A = 65 = 0x41
```



문자열 내에서는 숫자를 표현할 수 없다

- 숫자 10은 16진수로 0x0a 즉, LF를 나타내는 숫자이다

```
'hello 97 python'
>>> 'hello 97 python'
```



파이썬 문자열에서는 숫자입력을 할 수 있는 방법이 있다

- 16진수를 이용하면 표현이 가능
- 0x61 => \x61

```
'Hello \x61 Python'
>>> 'Hello a Python'

'\x68 \x65 \x6c \x6c \x6f'
>>> 'h e l l o'
```



##### 문자열 이스케이프

- 문자를 사용할 때, 충돌이 발생할 수 있다
  - 파이썬 인터프티어는 용도가 이미 정해진 문자들이 존재
  - 대표적으로 `' , " `과 같은 문자들이 그렇다
    - 문자열의 시작과 끝을 나타내는 용도로 사용
- 반대의 경우도 있다
  - 아무런 의미가 없는 문자인데, 특별한 의미를 부여하는 경우도 존재
  - `LF (0x0a , \n)` 가 그렇다



> 따옴표를 출력하고 싶다면?

```
# 파이썬 인터프리터는 이런 경우 해석할 수 없다
print(''따옴표를 출력하고 싶어요'')
>>> SyntaxError: invalid syntax
```

1. 출력하려는 따옴표와 문자열을 표현하는 따옴표를 다르게 사용
   - 따옴표인 경우에만 사용가능한 방법
   - 문자열 내에서 모든 문자를 전부 이런 식으로 표현할 수는 없음

```
# 작음 따옴표를 출력하고 싶다면, 문자열을 큰 따옴표로 표현
print("'따옴표를 출력하고 싶어요'")
>>> '따옴표를 출력하고 싶어요'

# 반대로, 큰 따옴표를 출력하고 싶다면, 문자열을 작은 따옴표로 표현
print('"이번엔 따옴표를 출력하고 싶어요"')
display('"이번엔 따옴표를 출력하고 싶어요"')
>>> "이번엔 따옴표를 출력하고 싶어요"
>>> '"이번엔 따옴표를 출력하고 싶어요"'
```



2. 탈출하고자 하는 문자앞에 `\`를 붙여준다
   - 탈출이라는 뜻은 '원래 의미를 벗어난다' 라는 의미로 해석

```
# 이번엔 같은 따옴표를 사용해서 출력해보자
print('\'작은 따옴표가 출력이 된다\'')
>>> '작은 따옴표가 출력이 된다'

# 큰 따옴표의 경우도 마찬가지
print("\"큰 따옴표가 출력이 된다\"")
display("\"큰 따옴표가 출력이 된다\"")
>> "큰 따옴표가 출력이 된다"
>>> '"큰 따옴표가 출력이 된다"'
# 문자열""에 문자열을 의미하는 ''
```



###### 경로를 표현하는 경우

- 특히, 윈도우즈에서 경로를 표현할 때, 폴더와 폴더의 구분자로 역슬래시를 사용하게 된다
- 경로란?
  - 디스크 상에서 파일(폴더)의 위치를 문자열로 표현
- 역슬래시도 마찬가지로 역슬래시로 `탈출`할 수 있다

```
# C:\Users\student\Videos\Captures 라는 경로
print('C:\\Users\\student\\Videos\\Captures')
>>> C:\Users\student\Videos\Captures
```



###### 반대의 경우

- 문자열 내에서 표현하기 힘든 문자들이 있다
  - 예를 들면 엔터가 그렇다
  - 표현하기 힘든 문자들에 대해서 입력할 수 있는 방법
  - 엔터, 탭, 백스페이스, ...

---

- LF는 뉴라인 이라는 의미로 사용
  - 뉴라인은 '문자열의 끝'을 의미
  - 문자열에서 뉴라인 문자가 나왔다는 건 거기서 문자열이 끝났음을 의미!

```
# 엔터를 문자열에서 표현하고 싶다면
# \n은 뉴라인(LF)이라고 한다
print("다음 라인에 출력하고 싶은데 \n 다음 라인에 출력")
print("다음 라인에 출력하고 싶은데 \x0a 다음 라인에 출력")
>>>다음 라인에 출력하고 싶은데
>>> 다음 라인에 출력
>>>다음 라인에 출력하고 싶은데
>>> 다음 라인에 출력
```

```
# 백스페이스를 표현
print("잘 쓰지는 않지만 백스페이스\b")
>>> 잘 쓰지는 않지만 백스페이
```

```
# 탭을 표현
print('탭을 \t 표현')
print('탭을 \x09 표현')
>>> 탭을	표현
>>> 탭을	표현
```



## 연산자

- 사칙연산 (+ , - , * , / )
  - 추가적인 사칙연산 : 지수연산(**), 몫연산(//), 나머지연산(%)
- 부호 (-)
  - 부호연산과 뺄셈의 차이는 피연산의 개수
- 불리언 연산자 (and, or, not)
- 비교연산자
  - = 를 같다는 의미로 사용할 수 없다 
    - 파이썬에서 = 는 이미 변수에 값을 할당, 저장하는 연산자로 사용됨
  - 같다 (==), 같지 않다 (!=), 크다(>), 작다 (<), 크거나 같다(>=), 작거나 같다(<=)



### 사칙연산

- 덧셈과 곱셈은 피연산자의 타입에 따라서 결과가 달라진다
  - 정수나 실수 타입 외에도 덧셈이나 곱셈이 가능하다
- 일반적인 정수(실수)의 덧셈이나 곱셈은 알고 있는 것과 동일하다

```
1 + 2
>>> 3

2 * 3
>>> 6
```

- 문자열에 대해서도 덧셈이나 곱셈이 가능하다

```
# 문자열의 덧셈은 문자열과 문자열의 결합
# 두 개 이상의 문자열을 하나의 문자열로 합칠 수 있다
'hello' + 'python'
>>> 'hellopython'

# 그렇기 때문에, 다음과 같은 경우에는 인터프리터가 해석할 수 없다
1 + '1'
>>> TypeError: unsupported operand type(s) for +: 'int' and 'str'
```

```
# 문자열의 곱셈은 반복의 의미로 해석
# 해당 문자열을 몇 번 반복할 것인가
# 피연산자의 타입이 반드시 달랴아 한다
'1' * 10
>>> '1111111111'

# 숫자를 먼저 써도 상관없다
10 * '1'
>>> '1111111111'

# 아래와 같은 경우에도 인터프리터는 해석할 수 없다
'1' * '10'
>>> TypeError: can't multiply sequence by non-int of type 'str'
```

###### 

#### 그 외 연산자들

```
# 지수 연산
print( 10 ** 2 )
>>> 100

print( 10 / 3 )
>>> 3.3333333333335

# 몫 연산
print( 10 // 3 )
>>> 3

# 나머지 연산
print( 10 % 3 )
>>> 1
```



#### 우선순위

- 우선순위를 외워두고 사용하기 보다는 ()를 통해서 우선순위를 명확하게 명시하도록 코드를 작성하는게 훨씬 쉬운 방법이다!

```
 # 여기서 >는 왼쪽이 우선임을 나타냄
 ()  >  **  > -(negative)  >  *, /, //, %  > +, -
```



```
# 우선순위가 같으면, 기본적으로 좌결합을 수행한다
# 왼쪽부터 차례대로 연산이 수행
2 - 3 - 4
>>> -5

print( 2 - (3 - 4) )
>>> 3

print( 2 - (3 + 4) )
>>> -5
```



### 논리연산

- and, or, not

- 명제들 간의 연산의 결과를 논리적으로 표현

  - 명제란 ? 참, 거짓을 구분할 수 있는 모든 문장

  - 파이썬은 실행 결과가 True, False를 반환하는 모든 명령어

    ```
    A B	AND	 or		not A	not B
    T T	 T	 T		F		F
    T F	 F	 T		F		T
    F T	 F	 T		T		F
    F F	 F	 F		T		T
    ```

    

- 우선순위
  - NOT > AND > OR

```
1 == 1
>>> True

1 == 2
>>> False

# 1과 1이 같고, 1과 2가 같다
1 == 1 and 1 == 2
>>> False

# 1과 1이 같고, 1과 2가 같거나 또는 1과 3이 같다
1 == 1 and 1 == 2 or 1 == 3
>>> False

# 1과 1이 같거나 또는 1과 2가 같고, 1과 3이 같다
1 == 1 or 1 == 2 and 1 ==3
>>> True
# 우선순위가 높은 and 먼저, 그 후 or
# 1과 1이 같다 True // 또는 // 1과 2가 같고 1과 3이 같다

# 우선순위를 고려하기 보다는 ()를 이용해서 정확하게 표현해주는 것이 더 쉽다
( 1 == 1 or 1 == 2 ) and 1 == 3
>>> False
# 1과 1이 같거나 1과 2가 같다 True // 그리고 // 1과 3이 같다 -> False
```





### 타입변환

- 파이썬은 비교적 자유롭게 타입을 변환할 수 있다
  - str(), int(), float(), bool()
  - str(x) : x를 문자열로 변환한 결과를 반환해 준다
  - int(x) : 실수, 문자열 x에 대해서 정수로 변환한 결과를 반환
  - float(x) : 정수, 문자열 x에 대해서 실수로 변환한 결과를 반환
  - bool(x) : 모든 타입의 x에 대해서 전부 참 또는 거짓으로 변환된 값을 반환



#### 문자열로 변환하는 경우

- 대부분의 타입은 큰 문제없이 문자열로 자유롭게 변환 가능

```
str(209384509283409580293845982039485)
>>> '290834759283745.0'

str(True)
>>> 'Ture'
```



#### 숫자타입간의 변환

- 작은 타입에서 큰 타입으로 변환하려는 경우

  - 여기에서 크다는 개념은 숫자의 대/소가 아닌, 표현범위를 의미

  ```
  # 정수 -> 실수
  float(10)
  >>> 10.0
  ```

- 큰 타입에서 작은 타입으로 변환하려는 경우

  - 표현의 범위가 줄어들기 때문에 유실되는 정보가 발생

  ```
  int(10.23)
  >>> 10
  ```

- 반올림

  - round()

  ```
  print( round( 10. 55555) )
  >>> 11
  # 소수점 이하는 전부 반올림
  
  # 소수점 2째 자리까지 반올림하려는 경우
  print( round(10. 555555555, 2) )
  >>> 10.56
  ```



#### 문자열을 정수나 실수로 변환

- 문자열 내에 문자들이 전부 10진수 정수 형태의 문자만 있어야 한다

```
int('92837458972394857928374587293847598273948579238')
>>> 92837458972394857928374587293847598273948579238


# 10진수 형태가 아닌 문자가 있을 경우
int('a92837458972394857928374587293847598273948579238')
>>> ValueError: invalid literal for int() with base 10: 'a92837458972394857928374587293847598273948579238'
```



#### 불리언 타입의 변환

- 타입과 상관없이 무조건 변환이 가능
  - 어떠한 타입이든 전부 True, False로 변환
  - 참, 거짓을 판단한 수 없는 경우에도 변환
- 불리언 타입 변환 규칙
  - 빈문자, 빈객체, 0은 무조건 거짓이 된다
  - 제외한 나머지는 무조건 참이 된다

```
bool(1 + 2)
>>> Ture



# 거짓이 되는 경우를 제외하면 모두 참이 된다
print( bool('') )
>>> False

print( bool (0) )
>>> False

bool()
>>> False

# 값이 존재하면 무조건 참이 된다
bool('거짓')
>>> True
```





## 메모리 (Memory)

- 우리가 알고 있는 그 메모리가 맞다
  - RAM (Random Access Memory)라고 부르는 메모리
  - 다른 말로 `주기억장치` 라고도 한다
  - 하드디스크(HDD), SSD, USB, ...
    - `보조기억장치`
    - 어떤 자료가 `보조기억장치에` 있을 때, 그 자료를 `파일` 이라고 부른다
- 주기억장치
  - 프로그럄이 실행 중인 동안에는 반드시 메모리에 있어야 한다
  - 즉, 다루려는 자료 또한 메모리에 있어야 한다
  - 메모리는 실행중인 프로그램(프로세스)에서 자료를 저장할 수 있는 공간
  - 명령어를 실행한 결과, 보조기억장치의 파일로부터 읽어들인 내용 등을 메모리 어딘가에 저장해두고 두고두고 꺼내서 사용하는 개념
  - 이러한 개념을 `변수`라고 한다
  - 메모리 어디에, 어떻게 저장되는지는 알 필요가 없다
  - 파이썬 인터프리터가 알아서 잘 결정하고 잘 관리해줌

  
### 주소 (Address)

- 메모리 상에서 값(자료)이 저장된 위치를 의미한다
- 파이썬은 변수를 주소를 기준으로 식별하게 된다
  - 주소는 변수(값)을 식별하는 유일한 값이 된다
- 자료는 비트의 형태로 저장이 되고, 1바이트(8비트)마다 번호를 부여
  - 메모리의 첫 번째 바이트의 주소는 0
  - 그 이후부터 1씩 증가하면서 번호가 부여
- 메모리의 크기가 아주 크기 때문에, 주소도 굉장히 큰 값이 나오게 된다
  - 주소는 일반적으로 10진수 보다는 16진수 형태의 표현을 많이 사용하게 된다

### 변수

- 메모리에 값을 저장해두고, 추후에 두고두고 다시 꺼내서 사용하거나 혹은 값을 업데이트 하는 용도로 사용하게 된다
  - 게임 캐릭터의 레벨을 생각해보자
  - 결국 레벨이라고 하는 것은 메모리 어딘가에 저장되어 있는 하나의 정보
  - 게임을 플레이하는 것은 메모리에 저장되어 있는 레벨을 업데이트 하는 것이라고 볼 수 있다
- 다시 꺼내서 사용하거나, 업데이트를 하기 위해서는 저장된 위치를 알고 있어야 한다
  - 주소는 숫자로 되어있고, 메모리의 크기는 매우 크고, 저장된 값도 너무 많기 때문에 전부 기억하는 것은 불가능 하다
  - 숫자 대신 문자로 대체해서 사용하기로 한다 -> 변수
- 결국 변수란, 값이 저장된 위치를 숫자 대신에 사용할 수 있는 이름
- 일반적으로 한 번 할당된 변수(메모리)는 프로세스가 종료될 때까지 계속 유지된다고 보면 된다


```
# 변수를 정의한다
# assignment(할당) => 메모리에 공간을 만들고, 만들어진 공간에 값을 저장
mem = 10


# 실제로 메모리 어디에 10이 저장되어 있는지는 모른다
# 이름을 통해서(mem) 메모리를 참조
mem
>>> 10
```



#### 변수의 이름 짓는 방법

- 변수의 이름은 임의로 직접 정해줘야 한다
- 파이썬은 한글 변수명도 사용이 가능하다
- 영문 대/소문자, 숫자, 한글을 상용
  - 특수문자는 몇몇 문자를 제외하면 사용할 수 없다
  - 사용할 수 있는 특수문자를 기억하기 보다는, 사용을 안 하는 것이 좋다
  - 파이썬은 특별하게 _(언더바. 언더스코어)를 사용할 수 있다
  - 숫자가 제일 앞에 올 수는 없다
- 파이썬에서 권장하는 변수 이름 짓는 방법
  - 변수의 이름은 소문자로 시작하도록 하자(권장)
  - 인터프리터가 이미 사용하고 있는 단어는 사용하지 않는 것이 좋다
    - True, int, ...
  - 변수 이름으로 피해야 하는 단어를 외워서 피하는 방법은 너무 어렵다
    - 일반적으로 사용하게 되는 개발환경에서 제공하는 에디터는 `컬러링`을 지원한다
    - 인터프리터가 이미 사용중인 단어에 대해서는 색으로 표시를 해준다
    - 내가 어떤 단어를 변수명으로 정의를 하려고 하는데 예쁘게 나온다? -> X


```
# 다음과 같은 변수명은 피해야 한다
int = 10

# int라는 이름이 변수명으로 사용되기 때문에 같은 이름의 int 명령어를 사용할 수 없게 된다
int('10') # 문자열 '10'을 정수로 변환하는 식
>>> TypeError: 'int' object is not callable
```

#### 타입 에러 해결 방법

> TypeError: ~~~ object in not callable

- 어디에선가 해당 이름으로 변수를 정의한 적이 있는 경우이다
- 정의된 변수를 찾아서 이름을 바꿔주고 런타임을 새로 실행해주면 해결할 수 있다

- 할당된 메모리를 제거하는 방법
  - del 명령어를 통해서 할 수 있다

```
del int

int('10')
>>> 10
```


### swap

- 두 변수의 값을 교환

```
a = 10
b = 20

imsi = a
a = b
b = imsi
print( a, b )
>>> 20 10
```

```
a = 10
b = 20
a, b = b, a
print( a, b )
>>> 20 10
```

#### 동적바인딩

```
a = 10
b = 20
print( hex( id(a) ) )
print( hex( id(b) ) )
>>> 0x5634021a1b20
>>> 0x5634021a1c60

# hex : 16진수로 변환
# id : 객체 고유의 값
```

```
a = b
print( hex( id(a) ) )
print( hex( id(b) ) )
>>> 0x5634021a1c60
>>> 0x5634021a1c60 
```

```
a = 10
print( hex( id(a) ) )
>>> 0x5634021a1b20
```


## 시퀀스 타입

- 기본 타입(숫자, 문자열)으로 이루어진 여러 개의 자료를 하나의 자료형으로 다루기 위한 방법
  - 문자열은 엄밀하게 따지면, 기본타입은 아니다
  - 다른 언어에서는 `배열`이라고 표현한다
  - 한 개의 식빵이 기본 타입이라고 한다면, 여러개의 식빵을 다루기 위한 자료의 타입중에 하나로 보면 된다
- 파이썬의 시퀀스 타입은 가장 기본적인 `자료구조`의 한 종류이다
  - 자료구조는 여러개의 자료를 관리하는 방법
- 파이썬에서 제공하는 시퀀스 타입의 종류
  - 리스트
    - 다른 언어에서 제공하는 `배열`의 개념이 파이썬에서는 이 리스트이다
    - 가장 많이 사용되는 자료형
    - `선형자료구조` 라고 한다
  - 튜플 (tuple)
    - 리스트와 동일한데, 가장 큰 차이점은 자료의 값을 변경할 수 있느냐 없느냐의 차이
    - 이런 차이를 제외하고는 리스트와 동일
    - 튜플은 튜플 내의 자료들의 값이 변하지 않음을 보장
  - 레인지 (range)
    - `수열`을 생성


### 불가변형 타입 VS 가변형 타입

- 불가변형 타입
  - 대표적으로 튜플이 불가변형 타입
  - 자료들의 값을 바꿀 수 없다
- 가변형 타입
  - 대표적으로 리스트가 가변형 타입
  - 리스트 내의 자료들에 대해서 값을 변경할 수 있다
- 가변형 타입에서만 사용할 수 있는 연산자가 따로 있다


### 튜플 (Tuple)

- `()` 로 표현

- 불가변형의 대표적인 타입
- 문자열은 튜플의 한 종류
  - 튜플의 속성을 그대로 따르면서, 문자열의 특징도 가지고 있다고 보면 됨

```
# 빈 튜플을 만드는 방법
# 원소가 한 개도 없는 튜플
# 빈 문자와 동일한 개념
arr = ()
type(arr)
>>> tuple

bool(arr)
>>> False
# 빈 문자열과 같음!
```



#### 튜플을 사용할 때 주의할 점

- 다음의 명령어는 튜플이 아니다

  ```
  arr = (1)
  print( type(arr) )
  print( arr )
  >>> <class 'int'>
  >>> 1
  # 튜플이 아니기 때문에 (1)이 아닌 1이 출력됨
  ```

- 튜플이 되려면 원소가 한 개 이상 존재해야 한다

  ```
  arr = (1, )
  print( type(arr) )
  print( arr )
  >>> <class 'tuple'>
  >>> (1, )
  
  # 콤마가 있다는 것은, 연속된 자료의 종류라고 판단
  ```

- ```
  arr = (1, 2, 3, 4, 5)
  print( type(arr) )
  print( arr )
  >>> <class 'tuple'>
  >>> (1, 2, 3, 4, 5)
  ```

#### 공통연산자

- 가변형 타입과 불가변형 타입 모두 동일하게 사용

```
arr = ( 10, 20, 30, 40, 50)
print( arr )
>>> (10, 20, 30, 40, 50)
```

- 시퀀스 내의 원소를 검색하는 경우

```
print( 10 in arr )
print( 100 in arr )
>>> True
>>> False


# 원소가 존재하면 False,  존재하지 않으면 True로 출력되도록 하는 방법
print( 10 not in arr )
print( 100 not in arr )
>>> False
>>> True
```

- 튜플도 문자열과 마찬가지로 덧셈과 곱셈 연산이 가능하다
  - 리스트로 동일하게 사용이 가능
  - 내용은 문자열과 동일하다

```
arr + ( 100, 200, 300 )
>>> ( 10, 20, 30, 40, 50, 100, 200, 300)

arr + 3
(10, 20, 30, 40, 50, 10, 20, 30, 40, 50, 10, 20, 30, 40, 50 )
```



- 어? 튜플은 내용이 변하지 않는다 그랬는데?
  - 원본은 변하지 않는다
  - arr 튜플과 새로운 튜플을 합친, 새로운 튜플을 반환해준다
  - 다시 `arr` 을 입력하면 `(10,20,30,40,50)`이 출력된다


#####  인덱싱과 슬라이스

- 파이썬의 시퀀스 타입은 자동을 인덱스가 생성된다
  - 0부터 순차적으로 1씩 증가하면서 자동으로 번호가 매겨진다
  - 문제는! 1이 아닌 0부터 시작이라는 점
  - 튜플(리스트) 의 첫 번째 원소의 인덱스는 0
  - 인덱스는 시퀀스 내에서 참조하길 원하는 원소를 선택

- 슬라이스는 시퀀스 내에서 원하는 `범위`의 요소를 선택하는 방법
  - 원하는 범위를 잘라서 가져오는 개념

- 프로그래밍의 핵심은
  - 반복문과 반복문을 이용한 인덱싱에 있다
  - 반드시 익여햐 하는 부분
  - 많은 연습 외에는 답이 없는 부분이다




###### 인덱스

```
arr
>>> (10, 20, 30, 40, 50)

# 내가 원하는 원소만 선택
print( arr[0] ) # arr 튜플의 인덱스0(1번째 원소)
print( arr[1] ) # arr 튜플의 인덱스1(2번째 원소)
print( arr[2] ) # arr 튜플의 인덱스0(3번째 원소)
print( arr[3] ) # arr 튜플의 인덱스0(4번째 원소)
print( arr[4] ) # arr 튜플의 인덱스0(5번째 원소)
>>> 10
>>> 20
>>> 30
>>> 40
>>> 50
```

- 주어진 시퀀스 타입의 범위를 벗어나는 참조를 한다면?
  - Index Out of Range 에러가 발생
    - 정말 많이 발생하는 에러중 하나

```
print( arr[5] )
>>> IndexError: tuple index out of range
```

```
# len() 은 시퀀스의 크기(길이)를 반환해 준다
# 시퀀스의 크기는 원소의 개수를 의미
len(arr)
>>> 5
```

- 시퀀스의 크기와 상관없이 항상마지막 원소를 참조하고 싶다면?

```
print( arr[ len(arr) ] )
>>> 50
# ( arr[4] ) 
```



- 파이썬은 음수 인덱스를 지원한다
  - 음수 인덱스도 자동으로 생성
  - 시퀀스 타입의 가장 마지막 원소부터 -1로 시작해서 순차적으로 1씩 감소하며 번호가 생성
- 시퀀스의 크기와 상관없이 항상 마지막 원소를 참조할 수 있다

```
print( arr )
print( arr [-1] )
>>> ( 10, 20, 30, 40, 50 )
>>> 50
```

```
print( arr )
print( arr[-1] ) # 맨 뒤(마지막)의 원소
print( arr[-2] ) # 맨 뒤에서 2번째 원소
print( arr[-3] ) # 맨 뒤에서 3번째 원소
print( arr[-4] ) # 맨 뒤에서 4번째 원소
print( arr[-5] ) # 맨 뒤에서 5번째 원소
>>> ( 10, 20, 30, 40, 50 )
>>> 50
>>> 40
>>> 30
>>> 20
>>> 10
```



- 음수인덱스를 사용하는 경우에도 범위를 벗어나지 않도록 주의해야 한다

```
print( arr[-6] )
>>> IndexError: tuple index out of range
```


- 원소 중 최대값과 최소값 찾기

  - ```
    arr = ( 60, 50, 20, 90, 70)
    
    print( min(arr) )
    >>> 20
    
    print( max(arr) )
    >>>90
    ```



###### 슬라이스

- 슬라이스는 범위 내의 원소를 잘라오는 기능
  - 멀티 인덱스 용도로 더 많이 사용된다
  - 파이썬의 슬라이스는 생각보다 빠르다
  - 사용할 수 있다면, 적극적으로 사용하는 것이 좋다
- 슬라이스의 사용법
  - s [ 시작인덱스 : 끝인덱스+1 ]
    - 파이썬에서 슬라이스를 하는 경우 **끝 인덱스의 원소는 포함하지 않는다**

```
arr = ( 10, 20, 30, 40, 50)

# 중간에 있는 20, 30, 40 3개의 원소만 선택하고 싶다면?
print( arr[1:4] ) # 2번째부터 (4-1)번째까지
>>> (20, 30, 40)
```


슬라이스의 여러가지 형태

- 전체 원소를 전부 선택하는 경우

  - 슬라이스를 하는 경우에는 마지막 인덱스의 범위를 확인하지 않는다

    - 마지막 인덱스는 범위를 벗어나도 괜찮다는 의미

  - ```
    print( arr[ 0:5 ] )
    >>> (10, 20, 30, 40, 50)
    
    print( arr[0:99999999999] )
    >>> (10, 20, 30, 40, 50)
    ```

  - 

  - 시작 인덱스와 끝 인덱스는 생략이 가능하다

    - 시작 인덱스가 생략되면 무조건 첫번째 원소부터 시작
    - 끝 인덱스가 생략되면 무조건 마지막 원소까지

  - ```
    print( arr[:] )
    >>> (10, 20, 30, 40, 50)
    
    print( arr[:4] )
    >>> (10, 20, 30, 40)
    
    print( arr[1:] )
    >>> (20, 30, 40, 50)
    ```



- 추가 기능

  - k의 기본값은 1이고, 생략이 가능하다

  - 이런형태

    - `print( arr[0:4:k] )`
      - `시작 인덱스부터 끝 인덱스까지 k씩 증가하며`

  - ```
    # 짝수번째 인덱스의 원소들만 선택하려면?
    print( arr[ 0::2] ) # -> 0, 2, 4, 6, 8, ... (k즉 2씩 증가), 끝 인덱스는 생략한 형태 
    >>> (10, 30, 50)
    
    # 홀수번째 인덱스의 원소들만 선택하려면?
    print( arr[1::2] ) # -> 1, 3, 5, 7, 9, ... (k 즉 2씩 증가), 끝 인덱스는 생략한 형태
    ```

- 음수 인덱스

  - ```
    ( 10 20 30 40 50 )
    [  0  1  2  3  4 ]
    [ -1 -2 -3 -4 -5 ]
    ```

    - step이 양수라면 0부터 시작
    - step이 음수하면 -1부터 시작

  - ```
    # 음수 인덱스
    print( arr[ -1: -6 : -1 ] )
    >>> (50, 40, 30, 20, 10)
    # 앞에서 다룬 음수인덱스와 마찬가지로 -1은 마지막 원소를 뜻함
    # 마지막 원소부터 [-6](끝인덱스는 포함X)까지 -1씩 증가하며
    
    # 뒤집기
    #시퀀스에 대해 매우 쉽게 reverse 연산이 가능하다
    print( arr[::-1] )
    >>> (50, 40, 30, 20, 10)
    # arr[-1], arr[-2], arr[-3], arr[-4], arr[-5]
    ```

    


#### 문자열

- 문자열도 시퀀스 타입의 한 종류
  - 튜플의 한 종류
  - 그래서, 문자열도 튜플처럼 사용할 수 있다
  - 튜플의 속성과 추가적으로 문자열의 속성을 갖게 된다

```
string = 'hello'

print( string[0] )
>>> h

print( string[::-1] )
>>> olleh
```



##### 가변 연산자

- 가변형 타입에서만 사용가능한 명령어(연산)
- 튜플에서는 확인할 수 없다


### 리스트 (list)

- 파이썬에서 가장 많이 사용하는 자료형
- 다른 언어에서는 `배열`이라고 부른다
- 파이썬에서 자료를 다루는 가장 기본적인 형태이면서, 가장 기본적인 자료구조이기도 하다

```
# 빈 리스트를 만드는 방법
arr = []
type( arr )
>>> list


# 초기화된 리스트를 만드는 방법
arr = [10, 20, 30, 40]
print( arr )
>>> [10, 20, 30, 40]
```



####  공통 연산자

- 튜플과 동일하다. 똑같이 사용할 수 있음



#### 가변 연산자

```
strings = 'Hello'
print( strings[1] )
>>> e
```


- 리스트를 수정하는 방법

```
print( arr )
>>> [10, 20, 30, 40]

arr[0] = 1
print( arr )
>>> [1, 20, 30, 40]
```




---

>### (번외) 문자열을 수정하려면?

```
strings = 'Hello'
print(strings[0])
>>> H

# H를 소문자 h로 변경하려면?
# 리스트로 변경 후, 바꿔줘야 한다

liststrings = list(strings)
# list() 는 리스트로 변경해준다

liststrings
>>> ['H', 'e', 'l', 'l', 'o']

liststrings[0] = 'h'

liststrings
>>> ['h', 'e', 'l', 'l', 'o']

strings2 = ''.join(liststrings)
# ''.join() 은 리스트를 문자열로 변경해준다

strings2
>>> 'hello'
```

---


##### 리스트에 원소를 추가하는 명령어

###### append VS extend

- 리스트에서만 사용이 가능하다
- 원소를 하나만 추가하는 경우와 여러 개를 한꺼번에 추가하는 경우

###### append

- append를 이용하면 리스트의 가장 마지막(맨 끝)에 원소를 추가
- 이때, 명령어를 실행한 결과를 반환하지 않는다

```
arr = [10, 20, 30, 40]

print(arr)
>>> [10, 20, 30, 40]


arr.append(50)
# 실행결과를 반환하지 않기 때문에 print()로 직접 확인
print(arr)
>>> [10, 20, 30, 40, 50]
```





---

> 돌려주는 경우와 돌려주지 않는 경우
>
> - (반환되는 경우와 반환되지 않는 경우)
>
> - (실행 결과가 자동으로 출력되는 경우와 출력되지 안는 경우)
>
> - 원본 자료형이 직접 바뀌는 경우에는 돌려주지 않는다
> - 파이썬에서 돌려주는 경우, 새로운 자료가 만들어진 경우에만 돌려주게 된다

---




###### extend

- 원소 여러개를 추가하는 경우

  - 리스트와 리스트를 더해서 새로운 변수로 할당

  - extend를 이용하는 방법은 동일한 명령어이다

```
arr = [1, 2, 3, 4]
print(arr)
>>> [1, 2, 3, 4]

arr.extend( [5,6,7] )
# 원본이 변경되었기 때문에 역시 실행결과를 돌려주지 않는다
print(arr)
>>> [1, 2, 3, 4, 5, 6, 7]
```

```
arr = [ 1, 2, 3, 4 ]

arr = [5, 6, 7]
print(arr)
>>> [1, 2, 3, 4]

# 새로 변수명을 정의 해줘야 변수를 통해서 참조가 가능하다
arr = arr + [5, 6, 7]
print(arr)
>>> [1, 2, 3, 4, 5, 6, 7]

# 간단하게
arr += [9 , 99, 999 ]
>>> [1, 2, 3, 4, 5, 6, 7, 9, 99, 999]
```


###### append 와 extend 의 차이점

- append(x) 는 리스트 끝에 x 1개를 그대로 넣는다

- extend(iterable) 은 리스트 끝에 iterable의 모든 항목을 넣는다

  - ```
    # append
    x = [1, 2, 3, 4]
    y = [5, 6, 7]
    
    x.append(y)
    print(x)
    >>> [1, 2, 3, 4, [5, 6, 7]]
    
    ######################
    
    # extend
    x = [1, 2, 3, 4]
    y = [5, 6, 7]
    
    x.extend(y)
    print(x)
    >>>> [1, 2, 3, 4, 5, 6, 7]
    ```

- append는 x에 y 그 자체를 원소로 넣는다
- extend는 x에 y의 각 원소들을 넣는다



- 리스트 안의 리스트를 추가한다면?

  - ```
    # append
    x = [1, 2, 3, 4]
    y = [5, 6, 7]
    
    x.append(y)
    print(x)
    >>> [1, 2, 3, 4, [5, 6, 7]]
    
    ######################
    
    # extend
    x = [1, 2, 3, 4]
    y = [5, 6, 7]
    
    x.extend(y)
    print(x)
    >>>> [1, 2, 3, 4, 5, 6, 7]
    ```

























